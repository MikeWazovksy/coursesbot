import logging
import html
import asyncio
import asyncpg
from aiogram import Router, F, Bot
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    Message,
    CallbackQuery,
    LabeledPrice,
    PreCheckoutQuery,
    SuccessfulPayment,
)
from aiogram.utils.markdown import hbold, hlink

from keyboards.user_kb import *
from models import users as users_db
from models import courses as courses_db
from models import payments as payments_db
from models import user_courses as user_courses_db
from models import settings as settings_db
from config import PAYMENT_PROVIDER_TOKEN, ADMIN_IDS

user_router = Router()


@user_router.message(CommandStart())
async def handle_start(message: Message, pool: asyncpg.Pool):
    user = message.from_user

    await users_db.add_user(
        pool, user_id=user.id, username=user.username, full_name=user.full_name
    )

    welcome_message = await settings_db.get_setting(pool, "welcome_message")
    if not welcome_message:
        welcome_message = f"üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!\n–Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ –æ—Å–≤–æ–∏—Ç—å –∑–∞–∫—É–ø–∫–∏ —Ç–æ–≤–∞—Ä–æ–≤ –∏–∑ –ö–∏—Ç–∞—è.\n–í—ã–±–µ—Ä–∏ –Ω—É–∂–Ω—ã–π —Ä–∞–∑–¥–µ–ª –Ω–∏–∂–µ"

    # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–∞ {user_name}
    welcome_message = welcome_message.replace("{user_name}", user.first_name)


    await message.answer(
        welcome_message,
        reply_markup=main_menu_kb,
    )


@user_router.message(F.text == "üéì –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫—É—Ä—Å—ã")
async def handle_catalog(message: Message, pool: asyncpg.Pool):
    courses = await courses_db.get_all_courses(pool)
    if not courses:
        await message.answer("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Å–µ–π—á–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—É—Ä—Å–æ–≤.")
        return
    await message.answer("–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫—É—Ä—Å—ã:", reply_markup=get_courses_list_kb(courses))


@user_router.callback_query(CourseCallbackFactory.filter(F.action == "view"))
async def show_course_details(
    callback: CallbackQuery, callback_data: CourseCallbackFactory, pool: asyncpg.Pool
):
    course_id = callback_data.course_id
    course = await courses_db.get_course_by_id(pool, course_id)
    if course:
        title = html.escape(course.get("title", ""))
        full_desc = html.escape(course.get("full_description", ""))
        price = course.get("price", 0)
        text = (
            f"üéì {hbold(title)}\n\n"
            f"{full_desc}\n\n"
            f"üí∞ {hbold('–¶–µ–Ω–∞:')} {price} —Ä—É–±."
        )
        await callback.message.edit_text(
            text, reply_markup=get_course_details_kb(course_id)
        )
    else:
        await callback.answer("–ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)
    await callback.answer()


async def expire_invoice_message(
    bot: Bot, pool: asyncpg.Pool, chat_id: int, message_id: int, payment_id: int
):
    await asyncio.sleep(600)
    payment_info = await payments_db.get_payment_info(pool, payment_id)
    if payment_info and payment_info["status"] == "pending":
        try:
            await payments_db.update_payment_status(pool, payment_id, "canceled")
            await bot.delete_message(chat_id=chat_id, message_id=message_id)
            await bot.send_message(
                chat_id=chat_id,
                text=f"‚ùå {hbold('–í—Ä–µ–º—è –¥–ª—è –æ–ø–ª–∞—Ç—ã –∏—Å—Ç–µ–∫–ª–æ!')}\n\n–î–ª—è –ø–æ–∫—É–ø–∫–∏ –∫—É—Ä—Å–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π —Å—á–µ—Ç.",
            )
        except Exception as e:
            logging.error(
                f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏—Å—Ç–µ–∫—à–∏–π —Å—á–µ—Ç (payment_id: {payment_id}): {e}"
            )


@user_router.callback_query(CourseCallbackFactory.filter(F.action == "buy"))
async def buy_course_handler(
    callback: CallbackQuery,
    callback_data: CourseCallbackFactory,
    bot: Bot,
    pool: asyncpg.Pool,
):
    await callback.answer()
    course_id = callback_data.course_id
    course = await courses_db.get_course_by_id(pool, course_id)
    if not course:
        await callback.message.answer("–ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        return

    title = html.escape(course.get("title", ""))
    short_desc = html.escape(course.get("short_description", ""))
    price = course.get("price", 0)
    user_id = callback.from_user.id

    payment_id = await payments_db.create_pending_payment(
        pool, user_id, course_id, price
    )
    if not payment_id:
        await callback.message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á–µ—Ç–∞.")
        return

    try:
        invoice_message = await bot.send_invoice(
            chat_id=user_id,
            title=title,
            description=short_desc,
            payload=f"payment_{payment_id}",
            provider_token=PAYMENT_PROVIDER_TOKEN,
            currency="RUB",
            prices=[
                LabeledPrice(label=f"–ü–æ–∫—É–ø–∫–∞ –∫—É—Ä—Å–∞: {title}", amount=int(price * 100))
            ],
        )
        asyncio.create_task(
            expire_invoice_message(
                bot,
                pool,
                invoice_message.chat.id,
                invoice_message.message_id,
                payment_id,
            )
        )
    except Exception as e:
        await callback.message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å—á–µ—Ç–∞.")
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–Ω–≤–æ–π—Å–∞: {e}")


@user_router.pre_checkout_query()
async def process_pre_checkout(
    pre_checkout_query: PreCheckoutQuery, bot: Bot, pool: asyncpg.Pool
):
    payload = pre_checkout_query.invoice_payload
    try:
        payment_id = int(payload.split("_")[1])
    except (ValueError, IndexError):
        await bot.answer_pre_checkout_query(
            pre_checkout_query.id, ok=False, error_message="–ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–ª–∞—Ç–µ–∂–∞."
        )
        return

    payment_info = await payments_db.get_payment_info(pool, payment_id)
    if not payment_info or payment_info["status"] != "pending":
        await bot.answer_pre_checkout_query(
            pre_checkout_query.id,
            ok=False,
            error_message="–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è —Å—á–µ—Ç–∞ –∏—Å—Ç–µ–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π —Å—á–µ—Ç.",
        )
        return
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)


@user_router.message(F.successful_payment)
async def process_successful_payment(message: Message, pool: asyncpg.Pool, bot: Bot):
    payment_id = int(message.successful_payment.invoice_payload.split("_")[1])
    payment_info = await payments_db.get_payment_info(pool, payment_id)
    if not payment_info:
        logging.error(
            f"–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–ª–∞—Ç–µ–∂–µ {payment_id} –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ–ø–ª–∞—Ç—ã."
        )
        return

    user_id = payment_info["user_id"]
    course_id = payment_info["course_id"]
    await payments_db.update_payment_status(pool, payment_id, "succeeded")
    await user_courses_db.add_user_course(pool, user_id, course_id)
    await message.answer("‚úÖ –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ! –í–∞–º –æ—Ç–∫—Ä—ã—Ç –¥–æ—Å—Ç—É–ø –∫ –∫—É—Ä—Å—É.")
    logging.info(f"–ü–ª–∞—Ç–µ–∂ {payment_id} —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}.")

    # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º
    try:
        course = await courses_db.get_course_by_id(pool, course_id)
        user = await users_db.get_user(pool, user_id)

        if course and user:
            user_full_name = html.escape(user.get("full_name", "N/A"))
            user_username = user.get("username", "N/A")
            course_title = html.escape(course.get("title", "N/A"))
            amount = payment_info.get("amount", 0)

            text = (
                f"üéâ {hbold('–ù–æ–≤–∞—è –ø–æ–∫—É–ø–∫–∞!')}\n\n"
                f"üë§ {hbold('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:')} {user_full_name} (@{user_username})\n"
                f"üéì {hbold('–ö—É—Ä—Å:')} ¬´{course_title}¬ª\n"
                f"üí∞ {hbold('–°—É–º–º–∞:')} {amount:.2f} —Ä—É–±."
            )

            for admin_id in ADMIN_IDS:
                await bot.send_message(admin_id, text)
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º: {e}")


@user_router.callback_query(CourseCallbackFactory.filter(F.action == "back_to_list"))
async def back_to_courses_list(callback: CallbackQuery, pool: asyncpg.Pool):
    courses = await courses_db.get_all_courses(pool)
    await callback.message.edit_text(
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫—É—Ä—Å—ã:", reply_markup=get_courses_list_kb(courses)
    )
    await callback.answer()


@user_router.message(F.text == "üìû –ö–æ–Ω—Ç–∞–∫—Ç")
async def handle_contact(message: Message):
    if ADMIN_IDS:
        admin_id = ADMIN_IDS[0]
        contact_link = hlink("–Ω–∞–ø–∏—Å–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É", f"tg://user?id={admin_id}")
        await message.answer(f"–î–ª—è —Å–≤—è–∑–∏ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π, {contact_link}.")
    else:
        await message.answer("–ö–æ–Ω—Ç–∞–∫—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.")


@user_router.message(F.text == "üìö –ú–æ–∏ –∫—É—Ä—Å—ã")
async def handle_my_courses(message: Message, pool: asyncpg.Pool):
    user_id = message.from_user.id
    my_courses = await user_courses_db.get_user_courses_with_details(pool, user_id)
    if not my_courses:
        await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∫—É–ø–ª–µ–Ω–Ω—ã—Ö –∫—É—Ä—Å–æ–≤.")
        return
    response_text = f"üìö {hbold('–í–∞—à–∏ –∫—É—Ä—Å—ã:')}\n\n"
    for course in my_courses:
        title = html.escape(course["title"])
        link = hlink("–°—Å—ã–ª–∫–∞ –Ω–∞ –º–∞—Ç–µ—Ä–∏–∞–ª—ã", course["materials_link"])
        response_text += f"üéì {hbold(title)}\nüîó {link}\n\n"
    await message.answer(response_text, disable_web_page_preview=True)


@user_router.message(F.text == "üßæ –ò—Å—Ç–æ—Ä–∏—è –ø–æ–∫—É–ø–æ–∫")
async def handle_purchase_history(message: Message, pool: asyncpg.Pool):
    user_id = message.from_user.id
    history = await payments_db.get_user_payment_history(pool, user_id)
    if not history:
        await message.answer("–í–∞—à–∞ –∏—Å—Ç–æ—Ä–∏—è –ø–æ–∫—É–ø–æ–∫ –ø—É—Å—Ç–∞.")
        return
    response_text = f"üßæ {hbold('–ò—Å—Ç–æ—Ä–∏—è –≤–∞—à–∏—Ö –ø–æ–∫—É–ø–æ–∫:')}\n\n"
    status_map = {
        "succeeded": "‚úÖ –£—Å–ø–µ—à–Ω–æ",
        "pending": "‚è≥ –í –æ–∂–∏–¥–∞–Ω–∏–∏",
        "canceled": "‚ùå –û—Ç–º–µ–Ω–µ–Ω",
    }
    for payment in history:
        status_emoji = status_map.get(payment["status"], "‚ùì")
        title = html.escape(payment["title"])
        amount_decimal = payment["amount"]
        amount_formatted = f"{amount_decimal:0.2f}".rstrip("0").rstrip(".")

        response_text += (
            f"{hbold('–ö—É—Ä—Å:')} {title}\n"
            f"{hbold('–°—É–º–º–∞:')} {amount_formatted} —Ä—É–±.\n"
            f"{hbold('–î–∞—Ç–∞:')} {payment['payment_date'].strftime('%Y-%m-%d %H:%M')}\n"
            f"{hbold('–°—Ç–∞—Ç—É—Å:')} {status_emoji}\n\n"
        )
    await message.answer(response_text)
